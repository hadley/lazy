% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stack.R
\name{stack}
\alias{call_caller}
\alias{call_env}
\alias{call_expr}
\alias{call_fun}
\alias{call_pos}
\alias{call_stack}
\alias{ctxt_caller}
\alias{ctxt_env}
\alias{ctxt_expr}
\alias{ctxt_fun}
\alias{ctxt_pos}
\alias{ctxt_stack}
\alias{stack}
\title{Call stack information}
\usage{
ctxt_pos()

ctxt_expr(n = 1)

ctxt_env(n = 1)

ctxt_caller(n = 1)

ctxt_fun(n = 1)

call_pos()

call_env(n = 1)

call_expr(n = 1)

call_caller(n = 1)

call_fun(n = 1)

ctxt_stack()

call_stack()
}
\arguments{
\item{n}{The number of frames to go back in the stack.}
}
\description{
The \code{ctxt_} and \code{call_} families of functions provide a
replacement for the base R functions prefixed with \code{sys.}, as
well as for \code{\link{parent.frame}()}. While the base
\code{sys.___()} functions are all about the context stack,
\code{\link{parent.frame}()} is the only base R function for
querying the call stack. The context stack includes all R-level
evaluation contexts. It is linear in terms of execution history but
due to lazy evaluation it is potentially nonlinear in terms of call
history. The call stack on the other hand is homogeneous in this
regard. See the vignette on execution contexts for more
information.
}
\details{
\itemize{
  \item The \code{_expr()}, \code{_env()}, and \code{_fun()}
        functions report about the call expression, the calling
        environment, and the caller function respectively.
  \item The \code{_pos()} and \code{_caller()} functions report
        about the callee and caller positions in the stack.
  \item Finally, the \code{ctxt_stack()} and \code{call_stack()}
        methods provide a summary of the context and call stacks
        with a handy \code{print()} method. They return a S3 object
        containing the following fields: \code{expr}, \code{env},
        \code{pos}, \code{caller} and \code{fun}
}

The base R functions take two sorts of arguments to indicate which
frame to query: \code{which} and \code{n}. The \code{n} argument is
straightforward: it's the number of frames to go back in the stack,
with \code{n = 1} referring to the current context. The
\code{which} argument is more complicated and changes meaning for
values lower than 1. For the sake of consistency, the lazyeval
functions all take the same kind of argument \code{n}. This
argument has a single meaning (the number of frames to go back in
the stack) and cannot be lower than 1.
}
\examples{
# Expressions within arguments count as contexts
identity(identity(ctxt_pos())) # returns 2

# But they are not part of the call stack because arguments are
# evaluated within the calling function (or the global environment
# if called at top level)
identity(identity(call_pos())) # returns 0

# The context stacks includes all intervening execution frames. The
# call stack doesn't:
f <- function(x) identity(x)
g <- function(cmd) cmd()
f(g(ctxt_stack))
f(g(call_stack))

#' # When called at top level, the output of ctxt_stack() is
# more consistent than that of sys.parents():
if (requireNamespace("purrr", quietly = TRUE)) {
  parents <- identity(identity(identity(sys.parents())))
  stack <- identity(identity(identity(ctxt_stack())))
  callers <- purrr::map_int(stack, "pos")

  parents
  callers
}
}

